/*
 * Copyright 2019 Jonathan Paz <omahaprogrammer@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.omahaprogrammer.crypto;

import com.omahaprogrammer.crypto.function.*;

import java.security.SecureRandom;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

/**
 * This class is a representation of a PHC-formatted string describing a protected password. Instances of this class may
 * be generated by parsing an existing PHC-formatted string or by building an instance with {@link PHC.Builder}. These
 * instances will then be able to verify that a given password matches the protected password, and to create a new
 * {@code PHC} object protecting a new password.
 * @param <T> The function driving the PHC object
 */
public final class PHC<T extends PHCFunction<T>> {

    /**
     * The list of supported PHC functions by name. Used for parsing.
     */
    private static final Map<String, PHCFunction<?>> functions;

    /**
     * The regular expression describing a PHC
     */
    private static final Pattern PHC_FORMAT_PATTERN = Pattern.compile("\\$(?<id>[a-z0-9-]*)" +
            "(?:\\$(?<params>[a-z0-9-]*=[a-zA-Z0-9/+.-]*(?:,[a-z0-9-]*=[a-zA-Z0-9/+.-]*)*))?" +
            "(?:\\$(?<salt>[a-zA-Z0-9/+.-]*)(?:\\$(?<hash>[a-zA-Z0-9/+.-]*))?)?");

    /**
     * The one-way function driving this object
     */
    private final T function;

    /**
     * The priority-ordered map of parameters with their associated values
     */
    private final NavigableMap<PHCFunction.Param<T, ?>, Object> params;

    /**
     * The cryptographic salt
     */
    private final byte[] salt;

    /**
     * The protected password, secured by the function with the associated salt
     */
    private final byte[] protectedPassword;

    static {
        var funcs = List.of(
                Argon2i.getInstance(),
                Argon2d.getInstance(),
                Argon2id.getInstance(),
                PBKDF2.getInstance());
        functions = funcs.stream().collect(Collectors.toMap(PHCFunction::getId, e -> e));
    }

    /**
     * Creates a new PHC object
     * @param function the function driving this object
     * @param params the function-specific parameters used to protect the password
     * @param salt the cryptographic salt used to protect the password
     * @param protectedPassword the result of the protection function on the cleartext password
     */
    private PHC(T function,
                  Map<PHCFunction.Param<T, ?>, Object> params,
                  byte[] salt,
                  byte[] protectedPassword) {
        this.function = function;
        this.params = Collections.unmodifiableNavigableMap(new TreeMap<>(params));
        this.salt = (salt == null) ? null : Arrays.copyOf(salt, salt.length);
        this.protectedPassword = (protectedPassword == null) ? null : Arrays.copyOf(protectedPassword, protectedPassword.length);
    }

    /**
     * Retrieves the function identified by the given string. Used during parsing
     * @param id the standard identifier of the function.
     * @return the function associated with the identifier
     */
    private static Optional<PHCFunction<?>> getFunction(String id) {
        return Optional.ofNullable(functions.get(id));
    }

    /**
     * Parses a PHC-formatted string and produces the corresponding object
     * @param phcString the PHC-formatted string
     * @param <T> the type of the function determined by the string
     * @return the fully populated PHC object represented by the string
     */
    public static <T extends PHCFunction<T>> PHC<T> parse(String phcString) {
        Matcher m = PHC_FORMAT_PATTERN.matcher(phcString);
        if (m.matches()) {
            var decoder = Base64.getDecoder();
            var id = m.group("id");
            var saltStr = m.group("salt");
            var hashStr = m.group("hash");
            var salt = (saltStr == null) ? null : decoder.decode(saltStr);
            var hash = (hashStr == null) ? null : decoder.decode(hashStr);
            var paramMap = extractParams(m.group("params"));
            var fOpt = getFunction(id);
            if (fOpt.isPresent()) {
                var function = fOpt.get();
                var typedParams = new TreeMap<PHCFunction.Param<?, ?>, Object>();
                for (var entry : paramMap.entrySet()) {
                    var param = function.getParam(entry.getKey());
                    param.ifPresent(p -> typedParams.put(p, p.validate(entry.getValue())));
                }
                @SuppressWarnings("unchecked")
                PHC<T> phc = new PHC(function, typedParams, salt, hash);
                return phc;
            } else {
                throw new IllegalArgumentException("Unknown function");
            }
        }
        throw new IllegalArgumentException("Unparseable token");
    }

    /**
     * Extracts the given parameters from
     * @param params the part of the PHC-formatted string describing the parameters
     * @return the map of key-value pairs describing the parameters
     */
    private static Map<String, String> extractParams(String params) {
        var paramMap = new HashMap<String, String>();
        if (params != null) {
            var tuples = params.split(",");
            for (var tuple : tuples) {
                var parts = tuple.split("=");
                paramMap.put(parts[0], parts[1]);
            }
        }
        return paramMap;
    }

    /**
     * Creates a new PHC object protecting the given cleartext password using the same parameters of this PHC. This
     * method will randomly derive a new salt of the same length as this PHC's salt. This method is intended for reusing
     * the parameters and function, not validating the given cleartext password.
     * @param password the cleartext password to protect
     * @return a new PHC object protecting the given password
     */
    public PHC<T> protectNewPassword(char[] password) {
        password = Arrays.copyOf(password, password.length);
        try {
            var newSalt = new byte[this.salt.length];
            new SecureRandom().nextBytes(newSalt);
            return new PHC<>(function, params, newSalt, function.protectPassword(params, newSalt, password, protectedPassword.length));
        } finally {
            Arrays.fill(password, '\0');
        }
    }

    /**
     * Creates a new PHC object protecting the given cleartext password using the same parameters of this PHC. This
     * method is intended for reusing the parameters and function, not validating the given cleartext password.
     * @param newSalt the new salt to use to protect this password.
     * @param password the cleartext password to protect
     * @return a new PHC object protecting the given password
     */
    public PHC<T> protectNewPassword(byte[] newSalt, char[] password) {
        password = Arrays.copyOf(password, password.length);
        try {
            return new PHC<>(function, params, newSalt, function.protectPassword(params, newSalt, password, protectedPassword.length));
        } finally {
            Arrays.fill(password, '\0');
        }
    }

    /**
     * The cryptographic one-way function that is used to protect the supplied password.
     * @return this PHC's function
     */
    public T getFunction() {
        return function;
    }

    /**
     * Retrieves the parameter value described for the given parameter
     * @param param the parameter whose value is to be retrieved
     * @param <V> the type of the value
     * @return the {@code Optional} containing the value of the object
     */
    public <V> Optional<V> getParam(PHCFunction.Param<T, V> param) {
        var v = params.get(param);
        if (v == null) {
            return Optional.empty();
        } else {
            return Optional.of(param.getValueClass().cast(params.get(param)));
        }
    }

    /**
     * The cryptographic salt used to protect the password
     * @return the salt, cloned
     */
    public byte[] getSalt() {
        return Arrays.copyOf(salt, salt.length);
    }

    /**
     * The protected password
     * @return the protected password, cloned
     */
    public byte[] getProtectedPassword() {
        return Arrays.copyOf(protectedPassword, protectedPassword.length);
    }

    /**
     * This method validates the given cleartext password against this PHC's protected password. This method will execute
     * the same protection function as described by this PHC and check the resulting bytes against the protected password
     * of this PHC.
     * @param password the cleartext password to validate
     * @return {@code true} if the given password is the same as the password protected by this PHC
     */
    public boolean validate(char[] password) {
        password = Arrays.copyOf(password, password.length);
        var testHash = function.protectPassword(params, salt, password, protectedPassword.length);
        Arrays.fill(password, '\0');
        var valid = true;
        for (int i = protectedPassword.length - 1; i >= 0; --i) {
            valid &= testHash[i] == protectedPassword[i];
        }
        return valid;
    }

    /**
     * Produces the text representation of this PHC according to the PHC format specification
     * @return the PHC-formatted text
     */
    @Override
    public String toString() {
        var encoder = Base64.getEncoder().withoutPadding();
        var b = new StringBuilder();
        b.append('$').append(function.getId());

        var first = true;
        for (var entry : params.entrySet()) {
            var key = entry.getKey();
            var value = key.validate(entry.getValue());
            if (key.getName() != null) {
                if (first) {
                    b.append('$');
                    first = false;
                } else {
                    b.append(',');
                }
                if (value instanceof byte[]) {
                    value = encoder.encodeToString((byte[])value);
                }
                b.append(key.getName()).append('=').append(value);
            }
        }
        if (salt != null) {
            b.append('$').append(encoder.encodeToString(salt));
            if (protectedPassword != null) {
                b.append('$').append(encoder.encodeToString(protectedPassword));
            }
        }
        return b.toString();
    }

    /**
     * Creates a new builder to construct a new PHC
     * @param function the function that will drive this PHC's functionality
     * @param <T> the type of the given function
     * @return the PHC builder
     */
    public static <T extends PHCFunction<T>> Builder<T> builder(T function) {
        return new Builder<>(function);
    }

    /**
     * This class provides a mechanism to construct a new PHC with the desired parameters.
     *
     * <p>This class provides two output mechanisms:
     * <ul>
     *     <li>Create a minimal PHC with the function alone with optional parameters and salt</li>
     *     <li>Create a full PHC that protects a password</li>
     * </ul>
     * </p>
     * @param <T> the type of the function
     */
    public static final class Builder<T extends PHCFunction<T>> {
        /**
         * The cryptographic function used to protect the password
         */
        private final T function;

        /**
         * The supplied parameters with values in priority order
         */
        private NavigableMap<PHCFunction.Param<T, ?>, Object> params = new TreeMap<>();

        /**
         * The cryptographic salt
         */
        private byte[] salt;

        /**
         * Creates a new builder with the given function
         * @param function the PHC function
         */
        private Builder(T function) {
            this.function = function;
        }

        /**
         * Sets the value for the given parameter. This parameter must be associated with the supplied function as described
         * by generics. The parameters will be supplied as public constants on the function class if available
         * @param param the parameter to set
         * @param value the value to set for the parameter
         * @param <V> the type of the value as described by the parameter
         * @return this builder object
         */
        public <V> Builder<T> withParam(PHCFunction.Param<T, V> param, V value) {
            this.params.put(param, value);
            return this;
        }

        /**
         * Sets the cryptographic salt to be used when protecting a password. A copy of the given array is stored
         * @param salt the cryptographic salt
         * @return this builder object
         */
        public Builder<T> withSalt(byte[] salt) {
            this.salt = Arrays.copyOf(salt, salt.length);
            return this;
        }

        /**
         * Randomly generates and saves a cryptographic salt with the default length as defined by the given function
         * @return this builder object
         */
        public Builder<T> withRandomSalt() {
            return withRandomSalt(function.getDefaultSaltLength());
        }

        /**
         * Randomly generates and saves a cryptographic salt with the given length
         * @return this builder object
         */
        public Builder<T> withRandomSalt(int sizeInBytes) {
            this.salt = new byte[sizeInBytes];
            new SecureRandom().nextBytes(salt);
            return this;
        }

        /**
         * Constructs a new, incomplete PHC function with the state as described by this builder at the time of execution.
         * @return a new PHC object
         */
        public PHC<T> build() {
            return new PHC<>(function, params, salt, null);
        }

        /**
         * Executes the protection function on the given password and constructs a new PHC with this information. The
         * length of the generated protected password is the default length thereof defined by the given function
         * @param password the cleartext password to protect
         * @return a new PHC object
         */
        public PHC<T> protect(char[] password) {
            return protect(password, function.getDefaultHashLength());
        }

        /**
         * Executes the protection function on the given password and constructs a new PHC with this information.
         * @param password the cleartext password to protect
         * @param hashLength the length of the protected password
         * @return a new PHC object
         */
        public PHC<T> protect(char[] password, int hashLength) {
            if (salt == null) {
                throw new IllegalStateException("Salt is required");
            }

            password = Arrays.copyOf(password, password.length);
            var hash = function.protectPassword(params, salt, password, hashLength);
            Arrays.fill(password, '\0');

            return new PHC<>(function, params, salt, hash);
        }
    }
}
